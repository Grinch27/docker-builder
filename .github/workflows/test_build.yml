name: (Test) build

on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      app_branch:
        description: "App Branch"
        type: string
        required: true
        default: "adguardvpn-cli"
      tag_repo:
        description: "Tag Push to Repo"
        type: string
        required: true
        default: "latest"

env:
  app_branch: ${{ inputs.app_branch }}
  tag_repo: ${{ inputs.tag_repo || 'latest' }}

jobs:
  build:
    name: Test build
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      pull-requests: write
    env:
      registry_local: "localhost:5000"
      version: ${{ needs.check.outputs.version || 'null' }}
      consistent: ${{ needs.check.outputs.consistent || 'false'}}
    steps:
      - name: Checkout ${{ github.repository }}
        uses: actions/checkout@main

      - name: (Log in) to Docker Hub
        if: ${{ 'true' == 'false' }} # disable
        uses: docker/login-action@master
        with:
          registry: docker.io
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Load Env
        id: env-app
        working-directory: "${{ github.workspace }}/${{ env.app_branch }}"
        run: |
          echo "Current working directory: $(pwd)"

          dir_step="env"
          dir_original=$(pwd)
          if [ -d "${dir_step}" ]; then
            cd ./${dir_step}
            echo "Changed to directory: $(pwd)"

            for env_file in ./*.env; do
              if [ -f "${env_file}" ]; then
                echo "Loading env file: ${env_file}"
                cat "${env_file}" | awk -F= '/^[a-zA-Z_][a-zA-Z0-9_]*=/ {printf "%s=%s\n", $1, $2}' | tee -a $GITHUB_ENV
              fi
            done

            cd "${dir_original}"
            echo "Changed back to original directory: $(pwd)"
          else
            echo "No directory found"
          fi

          echo "status=success" | tee -a ${GITHUB_OUTPUT}

      - name: Initialize environment
        id: init
        env:
          DEBIAN_FRONTEND: noninteractive
        working-directory: /
        run: |
          echo -e "Current working directory: $(pwd)"
          packages_install=(
            "ca-certificates"
            "curl"
            "gpg"
          )
          packages_extra=(
            "skopeo"
            "jq"
          )
          sudo -E apt-get -qq -y update
          sudo -E apt-get -y install "${packages_install[@]}"
          sudo -E apt-get -y install "${packages_extra[@]}"
          # sudo -E apt-get -qq -y autoremove --purge
          # sudo -E apt-get -qq clean
          echo "status=success" | tee -a ${GITHUB_OUTPUT}

      - name: Setup Docker
        id: docker
        env:
          DEBIAN_FRONTEND: noninteractive
        working-directory: /
        run: |
          # https://docs.docker.com/engine/install/ubuntu/

          # ===== 1. Set up Docker's apt repository =====
          # Add Docker's official GPG key:
          # sudo apt-get update
          # sudo apt-get install ca-certificates curl
          sudo install -m 0755 -d /etc/apt/keyrings
          sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
          sudo chmod a+r /etc/apt/keyrings/docker.asc

          # Add the repository to Apt sources:
          echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
            $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
            sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update

          # ===== 2. Install the Docker packages =====
          sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

          docker --version
          echo "status=success" | tee -a ${GITHUB_OUTPUT}

      - name: Setup QEMU
        id: qemu
        uses: docker/setup-qemu-action@master
        with:
          platforms: ${{ env.arch_branch }}

      - name: Setup Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@master
        with:
          version: latest
          driver-opts: network=host

      - name: (Service) Local Registry
        id: registry
        env:
          DEBIAN_FRONTEND: noninteractive
        working-directory: /
        run: |
          docker pull registry:latest
          docker run \
            --name registry \
            --detach \
            --network host \
            registry:latest
          echo "status=success" | tee -a ${GITHUB_OUTPUT}

      - name: Build and push to local registry
        id: build
        working-directory: "${{ github.workspace }}/${{ env.app_branch }}"
        run: |
          echo "Current working directory: $(pwd)"

          dir_step="build"
          dir_original=$(pwd)
          if [ -d "${dir_step}" ]; then
            cd ./${dir_step}
            echo "Changed to directory: $(pwd)"

            for script_file in ./*.sh; do
              chmod +x "${script_file}"
              sh "${script_file}"
            done

            cd "${dir_original}"
            echo "Changed back to original directory: $(pwd)"
          else
            echo "No directory found"
          fi

          echo "status=success" | tee -a ${GITHUB_OUTPUT}

      - name: Test Docker image & Inspect Layers with skopeo & Save to tar
        id: test
        env:
          container_name: container-test
          dir_container: "/tmp"
        working-directory: "${{ github.workspace }}/${{ env.app_branch }}"
        run: |
          echo "Current working directory: $(pwd)"

          IFS=',' read -ra platforms <<< "${{ env.arch_branch }}"
          for platform in "${platforms[@]}"; do
            os=$(echo ${platform} | cut -d'/' -f1)
            arch=$(echo ${platform} | cut -d'/' -f2-)
            
            variant=""
            if echo "${arch}" | grep -q "arm/v"; then
              variant=$(echo ${arch} | cut -d'/' -f2)
              arch=$(echo ${arch} | cut -d'/' -f1)
            fi
            
            skopeo inspect \
              --override-os=${os} \
              --override-arch=${arch} \
              ${variant:+--override-variant=${variant}} \
              --format=json \
              --tls-verify=false \
              docker://${{ env.registry_local }}/${{ env.repo_dockerhub }}:${{ env.tag_repo }}
            
            docker pull --platform $platform ${{ env.registry_local }}/${{ env.repo_dockerhub }}:${{ env.tag_repo }}
            docker run \
              --name ${{ env.container_name }} \
              --rm \
              --detach \
              --platform $platform \
              ${{ env.registry_local }}/${{ env.repo_dockerhub }}:${{ env.tag_repo }} \
              /bin/sh -c "uname -a && sleep infinity"

            dir_step="test"
            dir_original=$(pwd)
            if [ -d "${dir_step}" ]; then
              cd ./${dir_step}
              echo "Changed to directory: $(pwd)"

              set +e
              log_container=$(mktemp)
              docker exec ${{ env.container_name }} mkdir -p ${{ env.dir_container }}
              
              for script_file in ./*.sh; do
                container_script="${{ env.dir_container }}/$(basename ${script_file})"
                script_temp=$(mktemp)
                {
                  echo "#!/bin/sh"
                  printenv | awk -F= '/^[a-zA-Z_][a-zA-Z0-9_]*=/ {printf "%s=\"%s\"\n", $1, $2}'
                  cat "${script_file}"
                } > ${script_temp}

                docker cp ${script_temp} ${{ env.container_name }}:${container_script}
                docker exec ${{ env.container_name }} chmod +x ${container_script}
                docker exec ${{ env.container_name }} sh -c "${container_script}" | tee -a ${log_container}
              done
              set -e

              cd "${dir_original}"
              echo "Changed back to original directory: $(pwd)"
            else
              echo "No directory found"
            fi
            
            docker stop ${{ env.container_name }}

            tar_file="${{ env.app_branch }}_${{ env.tag_repo }}_${{ env.version }}_$(echo ${platform} | tr '/' '_').tar"
            docker tag ${{ env.registry_local }}/${{ env.repo_dockerhub }}:${{ env.tag_repo }} ${{ env.repo_dockerhub }}:${{ env.tag_repo }}
            docker save --output ./${tar_file} ${{ env.repo_dockerhub }}:${{ env.tag_repo }}
            echo "Exported $platform image to ${tar_file}"
          done
          echo "status=success" | tee -a ${GITHUB_OUTPUT}
