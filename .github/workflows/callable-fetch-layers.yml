name: Reusable Fetch Layers

on:
  workflow_call:
    inputs:
      image_name:
        required: true
        type: string

jobs:
  fetch:
    name: ${{ inputs.image_name }} - linux
    runs-on: ubuntu-latest
    steps:
      - name: Setup environment
        run: |
          sudo apt-get -qq update
          sudo apt-get -qq install -y ca-certificates curl gpg skopeo jq
      - name: Fetch Layer Info
        id: fetch
        run: |
          repo="${{ inputs.image_name }}"
          echo "Inspecting image (all linux platforms): $repo"

          raw=$(skopeo inspect --raw docker://docker.io/"${repo}" || true)

          # 提取 multi-arch manifest 中的 linux 平台
          platforms=$(echo "$raw" | jq -r '
              (.manifests? // [])
              | map(select(.platform.os=="linux"))
              | .[]
              | "\(.platform.architecture) \(.platform.variant // "")"
            ' | sort -u)

          if [ -z "$platforms" ]; then
            echo "No manifest list entries, fallback single inspect."
            single_json=$(skopeo inspect docker://docker.io/"${repo}")
            arch=$(echo "$single_json" | jq -r '.Architecture')
            os=$(echo "$single_json" | jq -r '.Os')
            if [ "$os" != "linux" ]; then
              echo "Image OS ($os) 不是 linux，退出." >&2
              exit 1
            fi
            platforms="$arch "
          fi

          echo "Found linux platform variants:"
          echo "$platforms"

          sanitized_name=$(echo "${{ inputs.image_name }}" | tr ':/' '_')
          echo "sanitized_name=${sanitized_name}" >> $GITHUB_OUTPUT
          # 聚合结构
          base_layers='{}'
          while read -r arch variant; do
            [ -z "$arch" ] && continue
            echo "Processing linux/$arch${variant:+/$variant}"
            data_json=$(skopeo inspect \
              --override-os=linux \
              --override-arch="$arch" \
              ${variant:+--override-variant="$variant"} \
              --format=json \
              docker://docker.io/"${repo}")
            layers_array=$(echo "$data_json" | jq -r '.Layers[]' | jq -R -s 'split("\n")|map(select(length>0))')
            key="linux_${arch}${variant:+_$variant}"
            base_layers=$(jq --arg k "$key" --argjson v "$layers_array" '. + {($k): $v}' <<< "$base_layers")
          done <<< "$platforms"
          # 平台列表输出
          echo "platforms_json<<EOF" >> $GITHUB_OUTPUT
          echo "$platforms" | awk '{print "linux/" $1 (length($2)?"/"$2:"")}' | jq -R -s 'split("\n")|map(select(length>0))' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          # 写聚合文件
          echo "$base_layers" | jq '.' > /tmp/all_layers.json
          # 输出紧凑JSON
          echo "base_layers=$(echo "$base_layers" | jq -c .)" >> $GITHUB_OUTPUT

      - name: Upload layer info
        uses: actions/upload-artifact@main
        with:
          name: layers-${{ steps.fetch.outputs.sanitized_name }}-linux
          path: /tmp/all_layers.json
          retention-days: 1
          if-no-files-found: warn
